# 使用指南

## 如何運行演示

### 1. 在 Xcode 中打開專案

```bash
open InterviewDemoProject.xcodeproj
```

### 2. 選擇模擬器或真機

- 在 Xcode 頂部選擇目標設備（例如：iPhone 16）

### 3. 運行專案

- 點擊 ▶️ 按鈕或按 `Cmd + R`

### 4. 進入 UI 繪製演示

- 在主畫面點擊右上方的 "🎨 UI 繪製演示" 按鈕
- 將進入演示界面

## 演示功能說明

### 主要元素

1. **標題區域**

   - 顯示演示名稱和說明

2. **同步繪製區域（紅色邊框）**

   - 在主線程執行繪製
   - 複雜繪製會阻塞主線程

3. **異步繪製區域（綠色邊框）**

   - 在後台線程執行繪製
   - 不會阻塞主線程

4. **控制面板**
   - 測試滑桿：檢測主線程響應性
   - 複雜繪製開關：控制是否繪製複雜圖形
   - 觸發重繪按鈕：手動觸發兩個視圖重繪

### 測試步驟

#### 測試 1：觀察繪製耗時

1. 打開 Xcode 控制台（Cmd + Shift + Y）
2. 點擊 "🔄 觸發重繪" 按鈕
3. 觀察控制台輸出：

```
==================================================
第 1 次重繪開始
==================================================
🔴 同步繪製耗時: 45.23ms
🟢 異步繪製耗時: 42.18ms
```

**注意**：

- 同步繪製的時間是在主線程上花費的
- 異步繪製的時間是在後台線程上花費的
- 即使耗時相似，異步繪製不會阻塞主線程

#### 測試 2：檢測主線程卡頓

1. 確保 "繪製複雜圖形" 開關是開啟的
2. 連續快速點擊 "觸發重繪" 按鈕 5-10 次
3. 同時拖動下方的滑桿

**預期結果**：

- ✅ 滑桿應該保持流暢（因為繪製在後台進行）
- ❌ 如果滑桿卡頓，說明主線程被阻塞（這不應該發生，因為異步繪製）

#### 測試 3：對比開關複雜繪製

1. 關閉 "繪製複雜圖形" 開關
2. 點擊 "觸發重繪"
3. 觀察耗時

4. 開啟 "繪製複雜圖形" 開關
5. 點擊 "觸發重繪"
6. 再次觀察耗時

**預期結果**：

- 開啟複雜繪製後，耗時會顯著增加
- 但界面仍應保持響應

## 代碼解析

### 核心概念

#### 1. 同步繪製（SyncDrawingView）

```swift
override func draw(_ rect: CGRect) {
    // ⚠️ 在主線程執行
    // ⚠️ 會阻塞主線程
    drawComplexGraphics(in: context, rect: rect)
    drawText(in: rect)
}
```

**特點**：

- 簡單直接
- 在 `draw(_:)` 方法中完成所有繪製
- 耗時操作會導致界面卡頓

#### 2. 異步繪製（AsyncDrawingView）

```swift
private func asyncRedraw() {
    // 1. 增加代數，標記新的繪製
    drawingGeneration += 1
    let currentGeneration = drawingGeneration

    // 2. 在主線程捕獲參數
    let context = DrawingContext(...)

    // 3. 在後台線程繪製
    drawingQueue.async {
        // 檢查是否過期
        guard currentGeneration == self.drawingGeneration else { return }

        // 執行繪製
        let image = drawContent(with: context)

        // 4. 回到主線程更新顯示
        DispatchQueue.main.async {
            guard currentGeneration == self.drawingGeneration else { return }
            self.layer.contents = image
        }
    }
}
```

**特點**：

- 不阻塞主線程
- 使用代數計數器防止過期繪製
- 在主線程捕獲參數快照
- 在後台線程執行繪製
- 回到主線程更新 UI

### 關鍵技術點

#### 1. Generation Counter（代數計數器）

**用途**：防止過期的繪製覆蓋新的繪製

```swift
var drawingGeneration: Int = 0

func asyncRedraw() {
    drawingGeneration += 1  // 新請求到來，增加代數
    let current = drawingGeneration

    DispatchQueue.global().async {
        // 開始繪製前檢查
        guard current == self.drawingGeneration else {
            print("過期了，不繪製")
            return
        }

        // ... 繪製 ...

        DispatchQueue.main.async {
            // 更新前再次檢查
            guard current == self.drawingGeneration else {
                print("過期了，不更新")
                return
            }
            self.layer.contents = image
        }
    }
}
```

**場景**：

- 用戶快速滾動列表
- 短時間內多次觸發重繪
- 確保顯示的是最新的內容

#### 2. 參數快照（DrawingContext）

**用途**：避免在後台線程訪問 UI 屬性

```swift
struct DrawingContext {
    let size: CGSize
    let text: String
    let font: UIFont
    let textColor: UIColor
    // ... 其他參數
}

// 在主線程創建快照
let snapshot = DrawingContext(
    size: bounds.size,
    text: text,
    font: font,
    textColor: textColor
)

// 在後台線程使用快照
drawingQueue.async {
    drawContent(with: snapshot)  // ✅ 安全
    // self.text  // ❌ 危險！不要在後台線程訪問 UI 屬性
}
```

#### 3. 位圖上下文創建

**用途**：在後台線程創建離屏繪製上下文

```swift
let scale = UIScreen.main.scale  // 支持 Retina 顯示
let width = Int(size.width * scale)
let height = Int(size.height * scale)

let context = CGContext(
    data: nil,
    width: width,
    height: height,
    bitsPerComponent: 8,
    bytesPerRow: 0,
    space: CGColorSpaceCreateDeviceRGB(),
    bitmapInfo: CGBitmapInfo.byteOrder32Little.rawValue |
                CGImageAlphaInfo.premultipliedFirst.rawValue
)

context.scaleBy(x: scale, y: scale)  // 坐標系統縮放
```

## 性能分析

### 使用 Instruments 分析

1. 在 Xcode 中選擇 `Product` > `Profile`（Cmd + I）
2. 選擇分析模板：
   - **Time Profiler**：分析 CPU 使用
   - **Core Animation**：分析渲染性能
   - **Allocations**：分析內存使用

### 觀察指標

1. **FPS（每秒幀數）**

   - 目標：保持 60 FPS
   - 每幀預算：16.67ms

2. **主線程佔用**

   - 同步繪製：會看到 `draw(_:)` 佔用大量時間
   - 異步繪製：主線程應該保持空閒

3. **內存使用**
   - 異步繪製會使用額外的緩衝區
   - 注意監控內存峰值

## 常見問題

### Q1：為什麼兩種方式的耗時差不多？

**A**：耗時相似是正常的，關鍵區別在於**在哪個線程執行**：

- 同步：在主線程，會阻塞 UI
- 異步：在後台線程，UI 保持流暢

### Q2：什麼時候應該使用異步繪製？

**A**：當滿足以下條件時：

- ✅ 繪製操作確實很耗時（> 10ms）
- ✅ 內容不需要立即顯示
- ✅ 內容相對靜態（不頻繁變化）
- ✅ 有足夠的內存空間

### Q3：異步繪製有什麼缺點？

**A**：主要缺點：

- 增加內存使用（需要額外的緩衝區）
- 增加代碼複雜度（線程同步、狀態管理）
- 內容顯示有延遲（需要等待後台繪製完成）
- 不適合動畫（頻繁變化的內容）

### Q4：能否看到明顯的卡頓差異？

**A**：在模擬器上可能不明顯，建議：

- 在真機上測試
- 增加繪製複雜度
- 同時進行其他操作（如滾動）
- 使用 Instruments 工具測量

## 擴展學習

### 進階主題

1. **YYText 框架**

   - 微信團隊開發的高性能文字渲染框架
   - 大量使用異步繪製技術
   - 源碼地址：https://github.com/ibireme/YYText

2. **Core Animation 深入**

   - 圖層樹結構
   - 離屏渲染
   - 圖層合成

3. **Metal 渲染**
   - 更底層的 GPU 控制
   - 適合遊戲和複雜圖形

### 相關面試問題

1. **解釋 iOS 的渲染流程**

   - CPU 階段：佈局、繪製、解碼
   - GPU 階段：頂點處理、光柵化、合成

2. **什麼是離屏渲染？如何避免？**

   - 定義、觸發條件、性能影響
   - 優化方案

3. **如何優化列表滾動性能？**

   - 複用機制
   - 異步繪製
   - 圖片解碼優化

4. **描述 UIView 和 CALayer 的關係**
   - 職責劃分
   - 為什麼要分層設計

## 總結

這個演示展示了：

- ✅ 同步繪製 vs 異步繪製的原理
- ✅ 異步繪製的實現方式
- ✅ 主線程卡頓的檢測方法
- ✅ 性能優化的思路

**核心要點**：

1. 異步繪製將耗時操作移到後台線程
2. 使用代數計數器防止過期繪製
3. 在主線程捕獲參數快照
4. 合理選擇繪製方式，不要過度優化

希望這個演示能幫助你理解 iOS 的 UI 繪製原理！
